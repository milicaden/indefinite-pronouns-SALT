library(plyr)
library(dplyr)
library(ggplot2)
library(tidyr)
library(minpack.lm)
source("./Indefinites_functions.R")

####################################
# DATA
####################################
Folder = "../data/"

# Generate a data frame with all logically possible items (in terms of which functions they can take).
allpossibilities <- expand.grid(rep(list(0:1), 10))
colnames(allpossibilities) <- c("spec.know", "spec.unkn", "irr.nonsp", "question", "condit", "indir.neg", "dir.neg", "compar", "free.ch", "neg.frag")

# Remove the one item that cannot take any of the functions.
allpossibilities = subset(allpossibilities, !(spec.know== 0 & spec.unkn ==0 & irr.nonsp ==0 & question == 0 & condit ==  0 & indir.neg ==  0 & dir.neg ==  0 & compar ==  0 & free.ch ==  0 & neg.frag == 0))

# Determine which possibilities satisfy Haspelmath's universals
allpossibilities$Haspelmath <- ifelse(((allpossibilities$spec.know == 0|allpossibilities$irr.nonsp==0)|allpossibilities$spec.unkn==1) & ((allpossibilities$spec.unkn == 0|allpossibilities$question==0)|allpossibilities$irr.nonsp==1) & ((allpossibilities$spec.unkn == 0|allpossibilities$condit==0)|allpossibilities$irr.nonsp==1) & ((allpossibilities$irr.nonsp == 0|allpossibilities$indir.neg==0)|(allpossibilities$question==1|(allpossibilities$condit==1&allpossibilities$compar==1))) & ((allpossibilities$irr.nonsp == 0|allpossibilities$compar==0)|(allpossibilities$condit==1|(allpossibilities$question==1&allpossibilities$indir.neg==1))) & ((allpossibilities$question == 0|allpossibilities$compar==0)|(allpossibilities$condit==1|allpossibilities$indir.neg==1)) & ((allpossibilities$condit == 0|allpossibilities$indir.neg==0)|(allpossibilities$question==1|allpossibilities$compar==1)) & ((allpossibilities$question == 0|allpossibilities$dir.neg==0)|allpossibilities$indir.neg==1) & ((allpossibilities$dir.neg == 0|allpossibilities$compar==0)|allpossibilities$indir.neg==1) & ((allpossibilities$condit == 0|allpossibilities$free.ch==0)|allpossibilities$compar==1) & ((allpossibilities$indir.neg == 0|allpossibilities$free.ch==0)|allpossibilities$compar==1) & (allpossibilities$spec.know==0|allpossibilities$compar==0) & (allpossibilities$spec.know==0|allpossibilities$free.ch==0) & ((allpossibilities$question+allpossibilities$condit+allpossibilities$indir.neg+allpossibilities$compar ==0)|(allpossibilities$question+allpossibilities$condit+allpossibilities$indir.neg+allpossibilities$compar > 2)) & (allpossibilities$neg.frag == 0|allpossibilities$dir.neg==1), "Haspel-ok", "Haspel-notok")
haspelpossibilities <- subset(allpossibilities, Haspelmath == "Haspel-ok")


# Whether to generate languages + measure complexity, or read the info from files
generate <- FALSE

#############################
# Generate artificial languages whose words satisfy Haspelmath's implicational map
#############################
fakefilename <- paste0(Folder, 'artificial_languages_exp2.csv')

if(generate) {
  fakelangdfhaspok = generate_languages(1, 5000, haspelpossibilities)
  fakelangdfhaspok$type = "Haspel-ok"


#############################
# Generate artificial languages whose words do not necessarily satisfy Haspelmath's implicational map
#############################
  fakelangdfhaspnotok = generate_languages(5001, 10000, allpossibilities)
  fakelangdfhaspnotok$type = "Not Haspel-ok"

# Put Haspel ok and not Haspel ok languages in a single df
df <-rbind(fakelangdfhaspok, fakelangdfhaspnotok)

write.csv(df, fakefilename)
} else {
  df <- read.csv(fakefilename)
}

####################################
# Additional estimates that will be useful in later computations
####################################

# Extract flavors for different items from Haspelmath's data based on our working assumptions
df = extract_flavors(df)

# Subset the data to relevant columns
relevant <- c("LANG", "ITEM", "skflavor", "suflavor", "nsflavor", "npiflavor", "fciflavor", "nqflavor", "Haspelmath", "type")
df <- df[relevant]

# Prep a data frame (cf. function prep)
df = prep(df)

# Complexity of a language in terms of Haspelmath's features
# Import minimal descriptions (generated by Min-desc-algo.R script)
min.desc = read.csv2(paste0(Folder, "minimum-desc-indef.csv"), header = TRUE)
df <- merge(df, min.desc[,c("meaning", "complexity", "names.descriptions.")], by = c("meaning"))

####################################
# COMPUTE COMMUNICATIVE COST AND COMPLEXITY OF LANGUAGES
####################################
compcostfile <- paste0(Folder, 'all_complexity_cost_exp2.csv')

if(generate) {
  allfinal <-compcostsyn(df)
  write.csv(allfinal, compcostfile, row.names=FALSE)
} else {
  allfinal <- read.csv(compcostfile)
}

####################################
# SYNONYMY MATCHING
####################################

generatesyn = FALSE
# Do synonymy matching
synfile = paste0(Folder, "syn_matched_exp2.csv")


if(generatesyn) {
  allfinal = synmatch(allfinal, "Haspel-ok", "Not Haspel-ok")
  write.csv(allfinal, synfile, row.names=FALSE)
}else {
  allfinal <- read.csv(synfile)
}

# Check that means of synonymity indices in two groups are roughly the same
mean(subset(allfinal, type == "Haspel-ok")$syn_index)
mean(subset(allfinal, type == "Not Haspel-ok")$syn_index)
